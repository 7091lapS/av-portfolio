<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Antonio Voce</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Antonio Voce - portfolio</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Passphrase"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ACCESS"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = false,
        staticryptConfig = {"encryptedMsg":"93478ffa706d12ba796a832bb9e870fac5e1a1469694b99b8ecc43e7e2b13a7b28f28854f0cfdce236c5ada1d440b293a436ac7b9cc74c8286bf267237ecfa5b69e0420faec2bdb4d5c2b472acf2ce7e5e815dde47074bdfd508d044330ca1a0830f87936bdee55bd2538cd9ca42cb61aaba35ff61bb67b315968bb4610d911438ddd56f9af5c937da78ac304b9ea9f1953969c744b5c9ed64df8a4352e32ca6ec972db949f885581b104e62b2f59b27d3a663034f3122a88f558a3736cfc8085eec338470e5ac4a73bde9f5909f9885cf3729e611b5fed41d3a396bc585c9460082d87ca9f61c052e4974ed65133c9123554481ce0fb7256c8f5ee067c7c93afc40b68998d4aae96145f9f3e9a6ec2b11170cc00a1b0f2ae4740153ea59ab20650b7e79483c3bbaf0a5de18246b1442d9f8bee29f6715c309244b30968220c6cf436c5836c5aafc1b1a31dc12c832851924e9bf85d3b02219eaf20c12997c293de3c0289b8d06073262884ccbc97eb8fa21efc5f6ea9c82e7e6aca95173bc57a56af5e1013fbbcf37a033bedfcdc63ac99c506e3265569598219005042812c2177fece18c608cdd04203c56792e8d1f688e461b62056853d2aa17c127d1368ba1e0be6ddc0e1ae9b3379ca27f685697543031c1ad518947be56407dbaebb32e5bc44fd5e6c8a0d9663221badae70c6407ae04313e54db2395af1bf34798a3c25c75090b35cf6c2b07dc90ddcf1647c89fabc9165d0f50a9b1ea97108c1382f362fee00818a30cbec1b6f527dce041082e0a33c51bb65de403a4a3054c7e6fd9c94187c1b51fb11472f8e7330d8cf18b3e1052be8cee1ff424b2a77999219482d58d8ea7736496727df7f43fb65314a59a1c17eb80b195324f767d6990790b48fcbc7659fac9f8b26d7c78d784cdcbe337afca82cb306a944910c0b2842db834e1173955eba843399e9bd8110adfd2712a1fa77f25fea2b465b30a3b60c12005fbd341dc96162ca8ebe5b1091924e448a3208e971628b1890b1b1830da34b6c4b7b6fda00b4cb9b233d99c3e30451084e238ad4d34fa2008d91f77d5b5be229fc8eb38100042d9f228150deaeef6fa7fba56e14f8d59d0473638ba2350d875338249da54772fe7fa749e4b14d506037085ab6ebc1b75697b19f314b3e1031e360389ea4f1c8135e2b70b4132ab9476db7b89d1e81430fe6c2ad1bf035d77da9787695f6a6296159300b106f4df11a5c59b733c74174e35e47924e9f9452400caddbcc431ad87822a63e677d6dfd10ed7b188913de8cfe28584855c9755bb5313edbfd38f5642ca3df699070cb8661b89960c8198186ba201615d929ef37b3343bb9b2b1836cc1ab1a34f66dcd916f113a23593782f04fbb3e0cbcef7c63a931785903ffddbf254ec6f3856fa3ba68175c79a0448f8912e204d0f28986db0b59d9677e18bb2d717a0fd5668dba1d7f6613d676cae044c098364ee2ef3f8af31049cd3ad516bb9de5a8c29dae9fc0e5564f98a7d3c310f8f07c11d2f013cce7cf88d69401c61ad6f0369afc005be910195b3b12b1f7e55987c751174aeb31dad27c4de736688d1221a86d5ddf301ba1727f0237dd5b127364cb6a44545d5162e97aacbe10d1fde6661317f84d66bc5e58beaa608fc350940152931329ff71b63b16facb65daf760cfa1ac9703ebb0ac5881c478009bfc0446a7b50f0fb1da16a7bca0ee20676b4db3cea9c8886e0f4d2481af6ce0a6b091efff76ac25777203c2f64fdeaf844fddc9ec820b8bb7b4f483c90b7194ecf6ec0f4c0268adf9467ee89e66a704f4a3cdaf0e432e297ad101e46091c7cc3defa0818b0ec7a8f27d696c5f54a56315ae7302162256fee5fad5544d470b1087f04590c0d4f96789fcb3a9a44ce4e59599a1bbf1a23f8a2f071feed65a022b67bf2142085c6ace1534bd4f0167fe9b4f4078bf39c7011f2f955ed09743633536ad4952da246bc969b7f5424c6ae9d2783cd19cb0bfe1153f11f643adfeb03642cc42381cd1881d8eff8fad12e8a3e092de04b83d1b65abc0328d113630cc8f40f23ac75e06f5ce4c34f071d0f5d17f21fa0b22c9524db2dde6a48df7056a7ec5c541297b48ce5afdc0a96437685864ac074e9b71babf20d8784a54258b5b7d47ac5a4813b75b094aeaf0a2114746d564066bb66f24adb9fc24ac31612218f02cf659611a5889cc8d81c32e2e807416dcb6c0f084db81261a1098af88fcaa200788913acf5d24273dc4d6e91d91b6faa5e2b82af1785ee106eac94ba9898551f95ecbba0ef6f33aa8fbf3a2643579a3788b167986761660b92c9796709137486d730e05ce5d1b4dfd08e024fc7df0e657e2c44b827f6745a89db5371b21bec6eb39f4b57c1c8f3b00d913d0106b1a442a74788d1a2d2c83657fb0a80b7eeb1e023c79849b05939ccdfccd4bc881197fb507815925154af9be873d34d78585ca2d51e66c96ce3d4b099c8a01d71a24dddae394ad6fffaf79c4df658709538fff44fc159ba59474cb5899db0ad03850b37a2aa0656f293e5c5eb815040b376b8aa02797992d795689a555db65717f9257cb56f4e4338cd197f0d5e09bf681b914b45694ab6b0d581ea2887632dfcad6d49f341ae833db2597e012ad6d9dac851e89479bdcb14034d2f3dc784f9efa3c88a556cddca79894ef68eda40d4088ce8be35cfccca67dcc2dc55ada5669d9acc75e33a2eed6d7b0f83575618d46039db87d559914dc5f025671d48b1af26fc6a186486e6bdd415ced2033e1fc3998411b9767fad190d0557278e135de2f8e62a717692360aafd1578271b9aaa5ceef77f4add2db07a5f74e4180796407d0ae8f5d14db54296e355510709bdc529ce13387ed75abf29790245afc6d774a622dc6b4ae9b96b2e2e8f11c4d9ec11474325a1ee9aace282efb26f961e81510f1c75fa43d8343e13b1242db6ff8f9063860848cb39680dff6c7ac2be351a10290b6e820393e1fb252d18f557e00affc6aab0104876f634aaf43d4bf6f7c6c95964a9a33d37ac7e260144478cc4e05e700a96391bc9b2961aa1e4ccf2c1ada61408b3ab846382862c1266b7cfddc68ff5f2649472929b92c0fd968164d0ef609dd6c55702a8fe7fe1311e13098b0ff4b36ce9598f06ff3034d12a4aee324564c4f9f525de5857819603309bf61a01e413c7fadc529c4fa66f4d5a457c5d81c4f971582829cc97c9afe782cf80f00af41c02a0a55b1abec028bbbcb1662a2dc7ebf9f15d0b546e0eab5a5c72979fd7409de0b77382fce01c06ae0d9c79193a3ca663bd04d088e430bbb5c3242c455a24f6a945632d80231c398fbfdc1fbcca7b27d5b205e253fd7fbf6a462a8e9b7f2a5af7a4024648680e83964d54950c6868cf96d925bc979588917161d0baebf41c56a5c094be4b27bc3b9115640f444c9cfff7020cd77364d7011370ac255366b0a3e84bd85cf511d8689e808cc81f482036dec695a2e94cf16a6fb7775f16a1895f7419f1174c2fb0e535f57dd4aef3d96fd25f87b986d5141218e426ab5528dbc810129f4b29b3ab37ed24b681767d7429427e3396645a522aa7fc417331c59bb41b22b54b5aef1e59cdaab1c6cbde48ed186117228c49fba329bc5b6b0bc3a8cba6b4b21bcdb0457b84f032ae8c3c8104a5992cbdb4aa516e4c88966f32a05da9ab80552ac4c861ab072c43a22c9d39afb4fe1e9cee680bd2455c3ab39485deb9aab086f9082078820512065969c60ea49be904240116721ebad3870228165aa1cb0765a23af7f84add28363360879aba581f54a9639bd87dfaed1489ac03b727e0510a8c5e534e47dca1c2a10994755054652adbdae0e1376c8389a9f0a59e3f6cbc0f9610074cd225da761332ddf321ecd163c8614570ac36ca3f80e0164568538472a20ad55063e2272640d9a30b2cb89326d9336dca719a12ed8eae8d0566d7cfbe24272546bb25ae302bb3d7cdac75bcde05aec5bd24a0c193b92bb4a2e4f4ce0990ea174d4939a63da7ee0c60abb5bb17b1eca827252ef77c05be27dab1e6f633bf1df6717e370385fb80393ff6a9edb1d0db56386e08ae9d6ab7b6f70b527b56425ba79f87d6c83524323820cca2ef0c7901788eb9fc327fe326047f8285a64a73c8d843384e350d17b3656116fe8f02dc8d80f78744e94840d2a0399e57afd5a145d9b9c7e8dfe6dfbc1abbe1d436eef5644cf790cdf5bd0ab8f513efaae747c5cf9aea92ef62e6ed86995ca85b9cb42c496981eba211ced145e84c7ec6b719d142c94e0d725b828a42338e00badfc6e95cef8bb59ac5746783c5510c9515ae68754f9968fca93b1ac7ca1bbaa0480e0875d1411d4521c387df933bffe09d9c57bf4e21ac487a26529bb27a77502274606e9c9e5806a447306726645f7a55583a5cfda5a869bae0e9f92f7e48b48fe3c100699af723d140ff9735f5f22bb84345f4ef3316e2230e5c5b3d5a3f262ec4b08b0b03df87058d6c56d79bdf5d02ac458411dbbc5df5a01be1fb7e3fc6a5e1a602bf22196667ae4a9e810b051a61b12950f1d3254de623a49a87ba793bc38cc8bf3484363d51695d7bf7a0482609cc7c851cd6010450a3c770ef601fbb6f968075092072913568c5d364ce4648714e5e4f7f496e8221d19bfe938d580c48f4e8f41d47d946a8dc386615d9809e36225111773c49f1e9c3386d3dc85fca55e2f753d2b48517c528f938d481e76fe731bf8cebee8e6a0be9b0d979c71daa5aae1776a3dfe770b2885bcda5f59a051d5b63f7a0073f92d0752c4522c11f36ef329d699f9f7f025715de89b8367e7d648a493ad1143521e4117f17b65e9e53bdc4ba5d06f6fe6d3f1dd31ca6ce1d3375f575fdc673cb8d84c96a3a75056b8a04ea51edab5da4ece7ac65687b45e3fc2eb887e2576a3aba82dd4fb101ffa66eaebeda2a2a964625dcb96b6deb6a9289dcaf61f9a5365e6aa4abe612f6ac435b08d751f5db8e951dee55957bdf16d2ce1c17d7242961b057401505284e6ea38b2130d12fff6b986d6d350bf7a1b1177ad45c8b1b933145adaa44152dca228b593ca9d75e338670fb559af0cf60a45d5eb4a5cfee25f63b344b743b3d2191506ff451a44b82fa08761a20ab2ae27a35e52389dd6612aedca0e4c0e28dbe0fd23e1e2e7e52693bf9f2447eefe3ed34659909b38ca5d1e17a006b549e3b463721c7c083bc3a90cd23257d31e6bee8852bc72f8ec60723f0410644e8e4eb2b5e44ed9264d31a0bd574802e351531e0a4ef7c9ccc236798b748418e1f6f95e1d13ef24fb71de313480d1a8cb3cea9ca920a1011727aedf85357151f93db68c029ea3ea89ef5b0102755101e62b705d137c78469602d2f5ef7c9df8e9aced5c745af09a0b564c950eb0f81ec1a26eb21649b1a5a7fba5ad898ddbb2d3b399ac2372fd3774aebc6aeb4ae60faaca4eab25b2e3d77e55729352e0d38835c34c25f84c303f82b44fbbb5892d6d4514ad890200f053f12c1105690e1537d7d4aabeb3942ede5511e8d32a3f1fbada4adde6f5e72d7d6be84f04e320524cb52cc63a431a7f4af90a96773da3e6d9b15610a309ff244fce777cf8725b502fcc7bee691d0bf385249a4da35ec2b6bbef2722da1dc9644e13c8943a00b2af17e06337244712f9ed66630b959280b3986220eaa7e3583c4fc20f8d177fba786490b179071a754171f2c6b81959f92ae77b5d00eab7b1cd1bd17abb6e564eeb8e4641812645230c0db605465b04eaadb25005c100e63d7c32a477c59a22a8a60a9282bccd08b4f202b12ff3bc3912e486f5d80b55c706a255aa96d2a685a03e790b30e3cb8e3b315df12eba5fc672730bb86c34426d39ada97b57f38b46995c6cef94c63dc55e94a91b86eedf1fce69229ee384119112e15ff72f454850a9b80260af922dab49f1da0ac48a73c9109ad02f33b3fb67bd0c2bfb0ce3b9f9fe2d7241c2c6846dc1884a106735d84749a23e26fb498b346ee863c3066f09b609cff4d0f134a623cee16f60cf1fc4e57de2126ed598983b17947647e4f763f0ad69f018c3185f47330440920d2eb5b574c8b8e742e341f4637e7fe7983e10f254034ae5618b491bff5192eb0ccf94b2cb90cac082aa89207ca7ac2d6262e1786e9a33609762301165b616bcdcfccdf2aae43b143e5ed8f6090728cfd69e05d37b48ee554f4fd77cc1d529526d9fa56e92799b24a8fa601810b29c96822bfe3f54a4c9e8eb8a89a9115f9e8d32e926732df8a0b26aa99c5f84e54b60fa3f8b718ed357fda5ccc89b2577a547f16bf7a7ac9c94108e07dc888d045eee8e156f90be610b10b99bb3e80e7efed51b8a939e5bf0a9192dcfa0bba3e493e26585f6e215bcdebd008cea96d5229790af6ed804c28ef817b4560d9066263b5fe27013f0c8817c3385751a6870a91ebf0755e42bc8b4b70ff210f29f487af19bbe23ce41ebf73bcac1862b89773351df3d33664dd1bc06b66f2c0200078a9c97a338fe01b47eadad24b0d7470b6ebdc6e946c19ba026e9c59fcfa131484d28b81cc8803b7a66a11fb2ad4361caa0c4362b8d9d3bcd96f10fee6a1ef926cfe3017b6a445323b5f19fa22c3ce05170e64abf5d3fc676ae20dda7f44372411b9a438a86d7aecb606ca0e2e4cc32b47e69ab40f4c0028238462100330076a262cbebde56b52411b3b4c93ce9ccc1dc2afac3e8771ce87212873c2548716aef47375f9f34b9ec8cb9e0b1ffafd5560bf99e9ef66e7eaf2153738f1f64d8c02aba52b61013aa59949efc7bcd138a737e5a26ac0ffd8214641d766611fdbd5f0c1ae9f78a66a2fb0618a692e79447b5e629ba897ce96e0eb4f07e36a2b02d609a7a5e1c626e2ea961d36bfb45e5d7735a0ab85ef65f41a98d1aaee65ddaacfec2d6b7d37df848a5d11d156f52e9f32f3a57c7a69f5d5bb60bf1f7c677521c20c1516b7053f762e382001b77f1b11900fdedad9b1981c477a69c87874a65aeea4e463df085a2453fdb090ad8f5eab9d86f6eee39294e3e351a97b6b5b6a19b2131d3358ae59a1a2e68a54d7a4e6482b4d04c8cfd38c6bcd20533b2c02e45e613b01438ebd572bf96629ad45138542d7ebf677d3947a4ca98b4b480123a01c8852a30f0c4333c1dd8f3fe58e37c2bb23973af7b1491a24e669d6969ef870449aee96aad90ab6d085f092f7fb3af5b4b5d020c34ed13cd7cce7639973365183bad9afda56e5fa5472d2c2973371e552033e495da0a767cfd5e056ec12db3682e0c408ac2e8c4aed0a8590ba43778beeb5231a87b40669b59e28b74a3e60c05b98a2b9c4b887ae15eba9b3c5d209d6069c02b76b42dfeb8217b4c8c88e2a5c832f32287234bc4d86031d9dfc4dfceffb5b2d6f9be5642ceb95d6ee70dc617414e9e11eb195fc5add273a6bc0f5da0e9af17f1361ae3aa11e5e5a54ac1070b9a7db6c1becc22ee3513e932a114261b962dd51f60f5c06165ab1966c66139a72db7b838335bbe5e218c4ae446b888476d35fe0c53e8535e3672d22a7442fe46cf32e470cc320dd5553c6253672ab0e1a05fa0ea7fc6417f837dd64b9848583ff3a9b15fd4c41b5049abee29b2ffb8715727596f53052c39f4f7d35342b84a293d0ed107ed1d5428bc8a43a451cf2b52ab70ccf118ff1b8d1fb972624460fa1fac2c424e77d637e78ea02b092b9a1a145620b83068387dee44d5cd1ba3d775dc55dc5d5a588734b190c64713198942b73344bba21ae307d8fe36a6e880c81357bf3efa5bcbe7257148fb6eeda8091795f9ecfb60ee18a3e9faf2f6a2c1a48d77080b5c01f880b65a5425f166c95bbbe50b0bcb9bc8d181d0368e11ca92d69bfad0bc7b4a61574178ee001142a6a2f1b6628184407ff50d81e373a7e2689134ca0da9d8ddc273a1fca76cdfb70d83fbfd16d51080ca01db396227e6f85ebcaa905f4945fb963eae449a937a615ba82f24aec868e271fe87f9e44e700e263efb6f6c7fb8c1107baff06b35da3c6a42b6f3e523586e4f73e5489192c0ac74d01aa7d1ca7300d8ebc38751472a3f94b889ea4456f4c08f41db6ea730245c01d944bf291bc92a9ef7190ca1c1057bd206e4961ba4e229ae52cb51e604cacbd6333c769426078c7a159f46011cccf20f2359337f0b52a8658139db7a3b73eb2f95eda985f0e6767876a2acc029e0d134963dd0b6d3b0e38d9e8ee887ff757dd495a848e3216bd3b9345817ab319ca2ddb4ea33c82c45df712b4d825a39200a0f61671543c3ab838eafd142149d583e5dc66edcc9ab110ebba15d71786cee272756ad45c4e3e1082514a0c3bb10f269d887bfefa95425156772dc6477392899d9f33e414f0821b5ecb1b22a6921fe813d2e4545590164df54e6bf9a9fde4740d613aaf6b5100b80b6cdf841eae5702e87fd31651268738c0b3f9b932be4da55395154072e650b938942496fc2f2691408881fdf59af07809fa1626cd2d25c8169b9f48b0ecd0e5c8676680469245dc654492b8f216afd9e94c339b26e35a29bab727786e9e2252634b3a0d8412f8fbf2a89d2f242b8dc10e18bad8fb07d44cf73b808b43dd5d3214256349b53b7dacb4ca6c5265ddae3e5f0bc541c0065a9087946e8892e2781728154e3e36c73b5ea51a4ff6e982df13c1427919eb216604feafac9cc500e1c8ce603071f37261f555d05435affcb6f9c277f5d22bbe6d1e8213b9808bc253b8b44462969ec4c4d5f64afb54a42c40b36df1ec8b55954bb221485617a39f6cabf50d4ec09d2a586671ad490da823e743d473a6c013f7f64e611267782845065336bf35553240234f72fb16e3c88e656c5f6e0aa8467d9db18d5aed54794d21f07b47ec9b652ef0102012998195af7024c4ed8bc30da1d6caecd149027a8036bef1df5f23cb7b7b9a2ebc573a8236c817ccc7e02314a13af420a3ad50cdee6f5d3f6bcdc906def957c29261720deeccc6930bcf0800d34bf1276d7cdffc512c35162d2be23d6104bd74b2dfba8bc0d6c8c76bca2534eadd7a5f639f86abbcd9235da02d8f47f93e4a8c3927fbe6d65da14a0aaab2caacab023a470da43ae62f7fdde1781c59ea4f2e66cf26f621591f28b011d3bc9fc1cca48c3e69da02970ba71ed7ad88d426c3f86fdd8918b859a7e51c4f6acf5e6c1e37da2a61749361b4aae49cac6255f80161c3a14bc20791aa10b72e3d9679f6075d92c0d50c4910062f605cd74e0071e56843aa545ab346b07b948c0314a9185e5a58298e2f2ab82b1f521b54a58abd750decdefccd4b3c1a4e38d1a5387abacd5043a103788ddf91a0afea0995466225a4d9ba46b06f1e80680a4de78845003f92944b64adb37afd87e69073a603f8960dbe08603599baa8045aea048a385c14a929255356aa4800b3198714b2b01192b0cedff7d062b361ef06075c6145b0a724f74644f857fac11ff385000e68dd0768fbc908aa9dddffbbd34fc24f13b7339cca3072ee9934dc9deef3788b526229367eba2ecb6d4cb73e2106d737eabce1b39db4e7db67b7e36ca43fd139d8fa20345b481d620556bb25511bde1f3c0f8941c2a4b5b7d4a25a1df3fa6f47d300c448a87bca7acbb41e0899d9d267c479577fdca0f55617ad240e9e89d02f76ae75eba78c27856f2974a66922d1f6c958e44b872513f68eb394a199d2b03eedeb245ad5c5359dddca639abfa216fc31a804635f83cc48753c0daeb019e955767db67d653ddaa47f70af6ced134a3c3a43a711587cddbefd75ca3d5f6b82d20383d6968d40ec2f9df79eccf84f7bae9ce86fe97f08b56e6f9f67d79820b657d0629d830d2eeb0d15303d24df1510c10b7d54c881aa73a1887981157a49f58615e38af1b51463f11e11194a5afcdfcc93be33146054034a2eb3ce652c74e1473a698a435678f87ae86cf66e34d26febb3a4f52f98eeaca05b7e0f931524967d28920e5af373b926217140cf23cd789a7d66ae076064db9675c661a9d84d61137457b95df05e1ecf80741f49237832fd24a84977bb22af62d084a4e2b3e4b2a8fb6d67799ff50152727c5e132c45c383f89188f2348bc9f6f86e2fe3e584f40869950c96b5f5cd6569c4fd016a96326fd16a927eb5b41a9993d1e0020e6dff55bde8809f1a38efccfa1c741cda302169da0ba7edd7f0c98877944e69b90c9eb44819786840054ad8388a5f992d34b9b9ee8bdbd43d3c9a1dd10c85f6de257cf4b51a4afb5ba31e9e1401d0f4bb07fa779081711b294bcf08959e39a8d60e7b12062566c5a92496fcab4175c67cee60f2b68574810e1c3ea1100551400a17c9c6cf14b80fd3696a0130a9b8e0c04dd1030266aeaa419e3bf89ea8e9dc1bc1337648da5d56cec87a19620cdf464c07af5a24f119112c9f9579b7f3ddb053c3a9e5ae0480e4d20543175146868623df1a5254c15ccbda114abf49557e8d16e1cf52f12e3b142baf7a49611bf7fd70762c333369341ab7e875d0cd8f5d5654babd58757f80c7d03882c08920b85e77a993f048668211b2bb0f2c2eb74e5fc74307bc3dead67dc8ce7228b54af2eb1c6e8219a0bc577088effa52592cad4e33503775e0ed256f2090113830651422c92026906b8e02e4bad3213f5a9fa6135d3136a2438909fa93eb2100f7c4193d7d7eac2fe3bc569372269c0f103df1899094cf90632554bc3611dc73fa957f4e993c5ffe9d6e12c7dcbb646a8acd29bf9e3d6acd16935623ade98dceb7eac796c8d09b7d8c423c719b0382ab7feb556332aa5acd83209d56d45b3ef14474b3e0d4200a8b451ad29a3b6c22414f4e1cca8b36c1d0860d2cc7184fc4721e8ac6cdcc5869d88d248b266c83e3aac8986339834c20169fdfd701edc56ed20b25a912eec15f7d940c8b4a03ac19f7fcf0f88260a56e9bfc6ee8242c1245e855aeb659819dad9e529b0d50c2cd13ba027669a0e25799342ae7746c4ebd767210ff023a3ef9bc49434e9c0842730d6de1a0292c38beb17c864dc04b9d4ed1da7bab05cbe8cd3c45cb1c1bd720b289c6209393d312792c0b0cde4121cd6ddde37a1df626836a4952acf0c44d57ca29533bcf7c71272bf8450bad572acd4ec52efab0769e61de8fc9270886e8d54e94f9ff5979b8328c53784563b6eabec3c33838d3d8707ed47a72f62eb6b40dd1aefbd13b475af3fb603e1fec4708647380f7112827766b97af05cd252d9872e49e6c0dd6674a72b2df78ec6e3433cb46795f23db908da765a0a10da1b8cebf1228d26ab8a95a76ea5fca58723bdc358c13e05ca510b9bb55827e9c56e964253b8c6716599045bf9918a6d0b2cb8f3c31ebe3916e10be91ba22f35713b65fe9219e43fd7dce41e618ddca0eeca64ed72b6e951d01763a487e7d5b16c6ce1d29db2f2d80fe0e58ac665da0ed324c7855c4e975b9ea7c0782fa48ec2dcf22f6b3025caecf33f2892e5eee40ef8e5d46b705232890a894a528311c63ad6f2fb28d667f14b9b376059b8e9187d19230f49526f98b5d871f8f8a4e931f7ea48474efd902ddeccd96de8b7419a690a6ff96d4e5c029829f133a229e6fd3d5cf759f2ee54731f66932ad986cd2e9b988ff24e42c5ccd787275b66a78e742e9d338e37c1d2f5da6604230ffdd91f9def8a570721be9fa40eb8b3bb7e3e66eaeb350d487d0df1b89ec751ef114875a035fc302956a8ab3f052b1124840d3fcf0f6e21f74e955814636267e68df07c4cf6a236cd627aa97e2bad0d75","isRememberEnabled":false,"rememberDurationInDays":0,"salt":"b3d18d44a6abe2411ac35ccd6484aaa7"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
